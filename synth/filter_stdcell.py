#!/usr/bin/python

import string, sys

# Usage: python filter_stdcell.py < input.lib
origLib = sys.stdin.read()

pos = 0
breaks = []
while True:
    # NOTE: Completely tied to the indentation of the original file; extra space avoids matching comment.
    cellStart = string.find(origLib, "  cell (", pos)
    if cellStart == -1:
        break
    cellClosePar = string.find(origLib, ")", cellStart)
    cellName = origLib[cellStart+8:cellClosePar]
    prevBlockEnd = string.rfind(origLib, "}", 0, cellStart)
    assert prevBlockEnd != -1
    blockStart = prevBlockEnd + 2
    breaks.append((cellName, blockStart))
    pos = cellClosePar
breaks.append(("__END__", string.rfind(origLib, "}")))

def basicFilter(cellName):
    (cellClass, _, cellStrength) = cellName.partition("_")
    if cellClass in ["INV", "NAND2", "NOR2", "BUF", "DFF"] and cellStrength == "X1":
        return cellClass
    return None

def multisizeFilter(cellName):
    for prefix in ["AND", "OR", "NAND", "NOR", "XOR", "XNOR", "INV", "BUF", "DFF_"]:
        if cellName.startswith(prefix):
            return cellName
    return None

def extendedFilter(cellName):
    (cellClass, _, cellStrength) = cellName.partition("_")
    if multisizeFilter(cellName) and cellStrength == "X1":
        return cellClass

for (outName, filter) in [("basic.lib", basicFilter), ("extended.lib", extendedFilter), ("multisize.lib", multisizeFilter)]:
    output = [origLib[0:breaks[0][1]]]
    for i in range(len(breaks) - 1):
        (cellName, startPos) = breaks[i]
        endPos = breaks[i+1][1]
        outCell = filter(cellName)
        if outCell:
            output.append(origLib[startPos:endPos].replace(cellName, outCell))
    output.append(origLib[breaks[-1][1]:])
    print "Saving %d/%d cells to %s" % (len(output) - 2, len(breaks) - 2, outName)
    f = open(outName, "w")
    print >>f, "/* Autogenerated subset of %d cells from library below -- DO NOT EDIT MANUALLY */" % (len(output) - 2,)
    print >>f, "".join(output)
    f.close()
